#include <random>
#include <bitcoin/bitcoin.hpp>

// The string we are searching for
const std::string search = "1kid";
// Generate a random secret key. A random 32 bytes.
bc::ec_secret random_secret(std::default_random_engine& engine);
// Extract the Bitcoin address from an EC secret.
std::string bitcoin_address(const bc::ec_secret& secret);
// Case insensitive comparison with the search string.
bool match_found(const std::string& address, std::string search);

int main(int argc, char *argv[])
{
    std::string search = search;
    if (argv[1]) search = (std::string) argv[1];
    std::cout << search + "\n";

	// random_device on Linux uses "/dev/urandom"
	// CAUTION: Depending on implementation this RNG may not be secure enough!
	// Do not use vanity keys generated by this example in production
	std::random_device random;
	std::default_random_engine engine(static_cast<unsigned int>(random()));
	// Loop continuously...
	while (true)
	{
		// Generate a random secret.
		bc::ec_secret secret = random_secret(engine);
		// Get the address.
		std::string address = bitcoin_address(secret);
		// Does it match our search string? (1kid)
		if (match_found(address, search))
		{
			// Success!
			std::cout << "Found vanity address! " << address << std::endl;
			std::cout << "Secret: " << bc::encode_hash(secret) << std::endl;
			return 0;
		}
	}
	// Should never reach here!
	return 0;
}

bc::ec_secret random_secret(std::default_random_engine& engine)
{
	// Create new secret...
	bc::ec_secret secret{};
	// Iterate through every byte setting a random value...
	for (uint8_t& byte: secret)
		byte = static_cast<uint8_t>(engine() % std::numeric_limits<uint8_t>::max());
	// Return result.
	return secret;
}

std::string bitcoin_address(const bc::ec_secret& secret)
{
	// Convert secret to pubkey...
	bc::ec_compressed compressed{};
    bc::secret_to_public(compressed, secret);
    auto pubkey = bc::wallet::ec_public(compressed);
	// Finally create address.
    auto payaddr = bc::wallet::payment_address(pubkey);
	// bc::wallet::payment_address payaddr;
	// bc::set_public_key(payaddr, pubkey);
	// Return encoded form.
	return payaddr.encoded();
}

bool match_found(const std::string& address, std::string search)
{
	auto addr_it = address.begin();
	// Loop through the search string comparing it to the lower case
	// character of the supplied address.
	for (auto it = search.begin(); it != search.end(); ++it, ++addr_it)
		if (*it != std::tolower(*addr_it))
			return false;
	// Reached end of search string, so address matches.
	return true;
}
